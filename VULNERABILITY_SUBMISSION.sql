-- Create vulnerabilities table for security team submissions
CREATE TABLE IF NOT EXISTS public.vulnerabilities (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  organization_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
  submitted_by UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  
  -- Vulnerability Details
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  severity TEXT NOT NULL CHECK (severity IN ('Critical', 'High', 'Medium', 'Low', 'Informational')),
  cvss_score DECIMAL(3,1) CHECK (cvss_score >= 0 AND cvss_score <= 10),
  affected_systems TEXT NOT NULL,
  remediation TEXT NOT NULL,
  
  -- Status and Approval
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
  admin_comments TEXT,
  approved_by UUID REFERENCES public.profiles(id),
  approved_at TIMESTAMPTZ,
  
  -- Timestamps
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.vulnerabilities ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Security team can view own submissions" ON public.vulnerabilities;
DROP POLICY IF EXISTS "Security team can insert vulnerabilities for assigned orgs" ON public.vulnerabilities;
DROP POLICY IF EXISTS "Security team can update own pending submissions" ON public.vulnerabilities;
DROP POLICY IF EXISTS "Admins can view all vulnerabilities" ON public.vulnerabilities;
DROP POLICY IF EXISTS "Admins can update vulnerabilities" ON public.vulnerabilities;

-- Security team can view their own submissions
CREATE POLICY "Security team can view own submissions"
  ON public.vulnerabilities FOR SELECT
  USING (
    submitted_by = auth.uid() OR
    public.is_admin_or_super_admin(auth.uid())
  );

-- Security team can insert vulnerabilities only for organizations assigned to them
CREATE POLICY "Security team can insert vulnerabilities for assigned orgs"
  ON public.vulnerabilities FOR INSERT
  WITH CHECK (
    submitted_by = auth.uid() AND
    EXISTS (
      SELECT 1 FROM public.security_team_organizations
      WHERE security_team_user_id = auth.uid()
      AND organization_id = public.vulnerabilities.organization_id
    )
  );

-- Security team can update their own pending submissions only
CREATE POLICY "Security team can update own pending submissions"
  ON public.vulnerabilities FOR UPDATE
  USING (
    submitted_by = auth.uid() AND
    status = 'pending'
  )
  WITH CHECK (
    submitted_by = auth.uid() AND
    status = 'pending'
  );

-- Admins can view all vulnerabilities
CREATE POLICY "Admins can view all vulnerabilities"
  ON public.vulnerabilities FOR SELECT
  USING (public.is_admin_or_super_admin(auth.uid()));

-- Admins can update all vulnerabilities (for approval/rejection)
CREATE POLICY "Admins can update vulnerabilities"
  ON public.vulnerabilities FOR UPDATE
  USING (public.is_admin_or_super_admin(auth.uid()));

-- Create index for faster queries
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_organization ON public.vulnerabilities(organization_id);
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_submitted_by ON public.vulnerabilities(submitted_by);
CREATE INDEX IF NOT EXISTS idx_vulnerabilities_status ON public.vulnerabilities(status);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS update_vulnerabilities_updated_at ON public.vulnerabilities;
CREATE TRIGGER update_vulnerabilities_updated_at
    BEFORE UPDATE ON public.vulnerabilities
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
